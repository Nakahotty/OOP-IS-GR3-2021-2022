# Упражнение 11

## Какво правихме предния път?
- ООП принципи (преговор)
- наследяване - идея и основни концепции
- упражнение - задачи върху наследяване

## Множествено наследяване

До сега разгледахме една дребна част от голямата картинка, свързана с наследяването. Вече знаем какво представлява и какви са му основните концепции (**преговор тук**), затова нека вникнем малко по-надълбоко.

Ще използваме думите:
- производен клас - за "наследниците"
- основен клас - за "бащата"

Наследяването (или по-скоро класовете, които имплменетирахме при наследяване) до сега използваше отношението ```1 основен -> n производни``` или с други думи разгледахме примери, в които има един основен клас и всички останали класове наследяват от него. Пример:

```c++
class Animal {

};

class Dog : public Animal {}
class Rabbit : public Animal {}
class Cat : public Animal {}
```

Какво обаче ще се случи, ако искаме да обърнем отношението по някакъв начин? Например един човек от ФМИ е възможно да бъде както **асистент** така и **студент** заедно с това. Ако трябва да преведм това на ООП език ще получим следното:

```c++
class Assistant {};

class Student {};

class Person : public Assistant, public Student {
    // множествено наследяване
}
```

Акцентът тук пада върху класа `Person`, който хем наследява от Assistant, хем от Student. Това е пример за **множествено наследяване**, което може да дефинираме по следния начин:

Множествено наследяване имаме тогава, когато един производен клас има повече от един основен клас, като производния клас комбинира характеристиките и поведението на **всиките си основни класове**.

Още един пример:

```c++
class Bot : public Player, public AI { ... };
```

### Конструктори и деструктори

- конструкторите на производния клас трябва да указват как се
конструират всяка една от наследените части
- ако за някой от основните класове не е указан кой конструктор да
се извика, тогава се извика този по подразбиране

    Пример:
```c++
    Bot::Bot(char const* _name, int _pts, char const* _algo,
            double _threshold, int _difficulty)
    : Player(_name, _pts), AI(_algo, _threshold),
    difficulty(_difficulty)
```

Деструкторите на основните класове се викат автоматично, без да
правим каквото и да било. 

**РЕД НА ИЗПЪЛНЯВАНЕ**

Конструкторите се викат в реда, в който наследяваме от класа, докато деструкторите се викат в обратния на този ред. С други думи, първо минават основните класове, от които се наследява, а чак накрая производния клас.

### Предефинирани функции

Предефинираните функции могат да извикат съответна функция във
всеки един от основните класове.

```c++
void Bot::print() const {
    Player::print();
    AI::print();
    cout << "Ниво на трудност: " << difficulty << endl;
}
```

### Голяма четворка

- системно генерираните методи от голямата четворка правят това,
което трябва
- конструкторът **по подразбиране**, за **копиране** и **оператор=** на производния клас извиква
съответните такива на основните класове
- винаги редът е същият като реда на наследяване


## Виртуални базови класове


## public, private, protected наследяване


