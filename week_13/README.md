# Упражнение 13

## Какво правихме предния път?
- виртуални функции, pure functions, override
- полиморфизъм - добри практики
- абстрактни класове

### От предният път - масив от фигури

Предният път разгледахме как можем да "третираме" различни фигури (кръг, квадрат, триъгълник...) просто като **Фигура**. За целта създавахме указатели към фигура, които инстанцираме с конструктора на съответния наследник.

```c++
Figure* figure1 = new Circle(5);
Figure* figure2 = new Rectangle(1,2);
Figure* figure3 = new Square(5);
```

За да можем да работим с масив от `Figures` като използваме двоен указател.

```c++
Figure** figures = new Figure*[3];
```

## Еднакви vs. Различни

![](images/ednakvi_razlichni.png)

Множество от "различни обекти"

*псевдо код*
```c++
Square* squares[] = { ... };
Circle* circles[] = { ... };
Triangle* triangles[] = { ... };
```

Множество от "еднакви"

*псевдо код*
```c++
Figure* figures[] = { new Square, new Circle ... }
```

**Указатели от Figure към Rectangle**

![](images/variant_1.png)

![](images/variant_2.png)


## Шаблони на функции

*Шаблони на функции и класове (полезна връзка за четене, cplusplus) - [templates](http://www.cplusplus.com/doc/oldtutorial/templates/)*

Шаблоните на функции са специални функции, които могат да работят с много различни типове. Това ни позволява да създадем шаблон за функция, чиято функционалност може да бъде адаптирана към повече от един тип или клас данни, без да се повтаря код за всеки отделен тип.

В C ++ това може да се постигне, като се използват **параметри на шаблона**. Това е специален вид параметър, който може да се използва за предаване на тип като аргумент: точно както обикновените параметри на функцията могат да се използват за подаване на стойности към дадена функция, параметрите на шаблона позволяват да се подават типове на функции. 

Форматът за деклариране на шаблони на функции с **типови параметри** е:
```c++
template <class identifier> function_declaration;
template <typename identifier> function_declaration;
```

Шаблонът на функцията започва с ключовата дума template, последван от параметър(и) на шаблона вътре в <>,
 което е последвано от дефиницията на функцията.
```
template <typename T>
T functionName(T parameter1, T parameter2, ...) 
{
    //...
}
```

В горния пример -  T е шаблонен аргумент, който приема различни типове данни (int, float и т.н.), а typename е ключова дума.
Когато аргумент от тип данни се предаде на functionName(), компилаторът генерира нова версия на functionName() за дадения тип данни.
(В горния пример резултатът,  който функцията връща също е от указания тип - Т)

## Извикване на шаблон на функция: 

След като сме декларирали и дефинирали шаблон на функция,
можем да го извикаме в други функции или шаблони (като функцията main()) със следния синтаксис : 
```c++
functionName<dataType>(parameter1, parameter2,...);
```
-експлицитно обявяваме типа на данните с които искаме функцията да работи, записвайки типа - dataType в <> след името на функцията

Пример:

Функция, която събира две числа от произволен тип и връща като резултат тяхната сума:
```c++
template <typename T>
T add(T num1, T num2) 
{
   return (num1 + num2);
}
```
Можем да извикаме функцията в main() - за int и double
```c++
int main() 
{
    int result1;
    double result2;

    // calling with int parameters
    result1 = add<int>(2, 3);
    cout << result1 << endl;

    // calling with double parameters
    result2 = add<double>(2.2, 3.3);
    cout << result2 << endl;

    return 0;
}   
```
```
output:

    2 + 3 = 5

    2.2 + 3.3 = 5.5
```

ВАЖНО функцията в горния пример няма да работи за типове, за които не е дефинирана операцията '+' (например, ако сме си дефинирали клас, в който не сме  имплементирали операцията '+') 

#### NB! И двата прототипа имат точно същото значение и се държат по същия начин.
#### Пример:
```c++
template <typename T>   // T e параметър на шаблона - това е типа, който по време на дефиницията на функцията не искаме да посочваме
T max_of_two (T a, T b) {
    return (a > b? a : b);
}
```
Когато искам е да извикаме функцията за определен от нас тип, тогава:
```c++
int main()
{
    int first = 5, second = 12;
    
    cout << max_of_two <int> (first, second); // посочваме типа при извикването на функцията

    return 0;
}
```
Какво се случва зад колисите: Когато компилаторът срещне това извикване на шаблона, той използва шаблона, за да генерира автоматично функция, заменяща всяко срещане на типа T с типа, подаден като параметър (int в този случай), и след това я извиква. Този процес се изпълнява автоматично от компилатора и е невидим за програмиста.
#### Можем да добавяме няколко параметъра на шаблона => няколко различни типа
```c++
template <typename T, typename S>
void print_pair(T a, S b) {
	cout << a << " and type is: " << typeid(a).name() << endl;
	cout << b << " and type is: " << typeid(b).name() << endl;
}
```