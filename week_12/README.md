# Упражнение 12

## Какво правихме предния път?
- множествено наследяване 
- ред на наследяване
- "диамантеният проблем"
- виртуални базови класове


## Виртуални функции:


Виртуалните функции са методи на базов клас и тези функции трябва да бъдат предефинирани(overridde) в класовете наследници(derive class).
Виртуалните функции гарантират, че е извикана правилната функция.

Виртуалните функции се декларират с ключовата дума virtual

Пример:
```c++
class Base {
public:
    virtual void print()
    {
        cout << "print base class\n";
    }
};
 
class Derived : public Base {
public:
    void print()
    {
        cout << "print derived class\n";
    }
};
```

## Чисто виртуални функции(pure virtual function):

Чисто виртуални функции са функции, които нямат имплементация. Имплементацията ще бъде написана от класа наследяващ базовия клас.

Пример:
```C++
class Base
{   
    // Data members of class
public:
    // Pure Virtual Function
    virtual void show() = 0;
    

   /* Other members */
};
```

## Полиморфизъм:

Време е да дадем пълна дефиния за последния, но не на последно място, ООП принцип - полиморфизмът. Полиморфизъм буквално преведено означава "много форми" (от poly - много, morphius - форми) или това практически е свойството на даден елемент да приема повече от една форма. Още по-конкретно в C++ всички наследници на един клас да могат да се "държат" като него и да могат да извършват всички негови функционалности.

Използваме го, когато един обект има различни поведения при различни ситуации.
Съществуват два типа полиморфизъм:
- **compile time** - този тип полиморфизъм се осъществява чрез function или operator overloading или предефиниране на оператор/функция.
	- предефиниране (**overloading**) на функции
		
        Пример:
    ```C++
	class FunctionOverload
    {
    public:
        // 1 параметър int
        void func(int x)
        {
            cout << "value of x is " << x << endl;
        }
        
        // 1 параметър double
        void func(double x)
        {
            cout << "value of x is " << x << endl;
        }
        
        // 2 параметъра
        void func(int x, int y)
        {
            cout << "value of x and y is " << x << ", " << y << endl;
        }
    };
  
    int main() {
        
        FunctionOverload obj1;
        
        // Коя функция от трите ще се изпълни, зависи от това какви параметри подаваме
        // Това вече сме го говорили.
        obj1.func(7);
        
        obj1.func(9.132);
        
        obj1.func(85,64);
        return 0;
    }	
    ```
	
	- предефиниране (**overloading**) на оператори:

        Пример:
    ```c++        
    class Complex {
    private:
        int real, imag;
    public:
        Complex(int r = 0, int i =0)  {real = r;   imag = i;}
        
        // това се вика автоматично при "сбор" на две комплексни числа
        Complex operator + (Complex const &obj) {
            Complex res;
            res.real = real + obj.real;
            res.imag = imag + obj.imag;
            return res;
        }
        void print() { cout << real << " + i" << imag << endl; }
    };
    
    int main()
    {
        Complex c1(10, 5), c2(2, 4);
        Complex c3 = c1 + c2; 
        c3.print();
    }
    ```

- **runtime** - възможно е чрез така нареченото **overriding** на функции - по-точно когато наследник на базов клас предефинира негова виртуална функция. 

    Пример:
    ```c++
    class base {
    public:
        virtual void print()
        {
            cout << "print base class\n";
        }
    
        void show()
        {
            cout << "show base class\n";
        }
    };
    
    class derived : public base {
    public:
        void print()
        {
            cout << "print derived class\n";
        }
    
        void show()
        {
            cout << "show derived class\n";
        }
    };

    int main() 
    {
        base *bptr;
        derived d;
        bptr = &d;
        
        // виртуална функция - runtime
        bptr->print(); 
        
        // стандартна функция - compile time
        bptr->show(); 
    
        return 0;
    } 
Изход:
```
print derived class
show base class
```

### Време е да видим проблем, който се решава именно с виртуалните функции.

```c++
class Entity {

};

class Player {

};
```

## override 
Използва се при дефиницията на виртуалния метод в наследниците. Може да ги възприемате като двойка - в базовия клас обозначаваме `virtual` един път, а за всеки наследник на базовия клас, който имплементира този метод при неговата дефиния обозначаваме `override`. Това НЕ Е задължително, за да осъществите правилното поведение на виртуалната функция, но е доста добро за четимост и компилаторът ще ви хвърли грешка, ако в бъдещете промените името на виртуалната функция - ще ви каже къде трябва да я промените надолу по веригата (в кои наследници).

## Абстрактни класове:

Абстракция - показване на нужната информация и скриване на детайлите.
Абстрактен клас е клас, който съдържа поне една pure virtual функция.

Пример:
```c++
class Base
{
	int x;
	public:
	virtual void show() = 0;
	
    int getX() { return x; }
};

int main(void)
{
	Base t;
	return 0;
}
```

Този пример ще доведе до compile error, защото не могат да бъдат създавани обекти от абстрактен клас.

Можем да създаваме референции от абстрактни класове, които да сочат към обекти от класове насладници на абстракния клас, които са имплементирали всички виртуални методи.
Ако класът наследник на абстрактия клас не предефинира виртуалните функции той също става абстарктен клас.