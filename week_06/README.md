# Упражнение 6

## Какво правихме предния път?
- предефиниране на оператори
- голяма четворка
- имлпементация на голяма четворка
- какво са header файловете

## static fields

Можем да дефинираме статични членове на класа с помощта на ключова дума static. Когато декларираме член-данна на клас като статична, това означава, че независимо колко обекта на класа са създадени, има само едно копие на статичната член-данна.

```c++
class A {
private:
    static int field;
};
```

Статичната член-данна **се споделя от всички обекти на класа**. Всички статични данни се инициализират на нула при създаването на първия обект, ако не е налице друга инициализация. Не можем да го поставим в дефиницията на класа, но може да бъде инициализиран извън класа, както е направено в следващия пример чрез повторно деклариране на статичната променлива, като се използва операторът `::`, за да се идентифицира към кой клас принадлежи.

```c++
int main() {
    std::cout << A::field << std::endl;
}
```

## static methods

Като декларираме функция като статична, ние я правим **независима от всеки един обект от този клас**. Статична функция-член може да бъде извикана, дори ако не съществуват обекти от класа и това се осъществява чрез използването отново на синтаксиса <име на клас>::<име на метод>

```c++
class A {
public:
    static void printField();
};

int main() {
    A::printField();
}
```

Статичната функция може да осъществява достъп **само до статичните член-данни**, други статични функции и всякакви други функции извън класа.

Статичните функции-членове имат обхват на класа и те нямат достъп до указателя this на класа. Можете да използвате функция за статичен член, за да определите дали някои обекти от класа са създадени или не например.

Въпрос: Защо не можем да достъпваме НЕ-СТАТИЧНИ член данни в СТАТИЧНИ методи?

## Exceptions (изключения)

При изпълнение на C++ код могат да възникнат различни грешки: грешки в синтактиса на кода, направени от програмиста, грешки поради неправилно въвеждане или други непредвидими неща.

Когато възникне грешка, C++ обикновено спира и генерира съобщение за грешка. Техническият термин за това е: C++ ще изведе изключение (изведе грешка). На английски ще го срещнете по-точно като `throw an exception (throw an error)`

### try and catch

Синтаксиса за справяне с грешки обикновенно се състои от ключовите думи: `try`, `throw`, `catch`:

- Операторът try ви позволява да дефинирате блок от код, който да бъде тестван за грешки, докато се изпълнява.

- Ключовата дума throw хвърля изключение, когато бъде открит проблем, което ни позволява да създадем персонализирана грешка.

- Операторът catch ви позволява да дефинирате блок код, който да бъде изпълнен, ако възникне грешка в блока try.

- Ключовите думи try and catch идват по двойки:

```c++
try {
  // Block of code to try
  throw exception; // Throw an exception when a problem arise
}
catch () {
  // Block of code to handle errors
}
```

Пример:
```c++
try {
  int age = 15;
  if (age >= 18) {
    cout << "Access granted - you are old enough.";
  } else {
    throw (age);
  }
}
catch (int myNum) {
  cout << "Access denied - You must be at least 18 years old.\n";
  cout << "Age is: " << myNum;
}
```

Обяснение:

Използваме блока `try`, за да тестваме някакъв код: Ако променливата възраст е по-малка от 18, ние ще хвърлим изключение и ще го обработваме в нашия блок `catch`.

В блока `catch` ние хващаме грешката и правим нещо по въпроса. Инструкцията `catch` приема параметър: в нашия пример използваме променлива int (myNum) (защото хвърляме изключение от тип int в блока `try` (age)), за да изведем стойността на age.

Ако не се появи грешка (например, ако възрастта е 20 вместо 15, което означава, че ще бъде по-голяма от 18), блокът за хващане се пропуска

## Move семантика

Move семантиката ни позволява да избягваме ненужни копирания на обекти, когато искаме да работим с тях временно (например в тялото на някой метод) и такива, които са на път да се изпарят и чиито ресурси могат безопасно да бъдат **взети** или **преместени** от този временен обект и използвани от друг.

Проблемът най-просто казано е следния - в повечето случаи когато искаме да вземем данните на някакво entity (class) и работим с динамична памет, ще трябва да заделяме памет **2 пъти**. Нека го покажем това с ръчно написан `String` :)

```c++
    insert String here
```

Какво се случва тук? Нека разгледаме ред по ред - задаваме size да ни е равен на предоставения `rvalue` или `temporary` - стойност която не сочи никъде в паметта.

По интересен е реда за приравняването на данните:

там **директно пренасочваме указателя от this->data в текущия scope на стринг към other или към данните на другия обект БЕЗ ДА ИМА НУЖДА ДА ЗАДЕЛЯМЕ НОВА ПАМЕТ ЗА ТЯХ.**

Следващите два реда са ключови (обърнете внимание на тях). Много е важно след като сме "превзели" данните на обекта `other` да ги изчистим от паметта, защото те вече не могат да бъдат достъпени по никакъв начин. Съответно трябва да занулим всяка една данна, която е била взета от нас при изпълнението на move constructor-а

```c++
String(String&& other) noexcept {
        std::cout << "Moved" << std::endl;
        this->size = other.size;
        this->data = other.data;  // assigning the pointer!!!
    
        other.size = 0;
        other.data = nullptr; // making other "hollow"
    }
```
